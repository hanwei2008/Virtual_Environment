#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author: caiyuantao
# @Date:   2014-12-18
# @Email: 755864446@qq.com
# feature.py
# Copyright (c) 2014 Chengdu Lanjing Data&Information Co., Ltd
from math import log
'''
文本的特征向量表示
输入：包含很多文本的文件夹经过分词，去停用词，词频统计等预处理后的counterlist，[counter,counter,...]
输出：每个文本的特征向量表示，[vector,vector,...]
'''


# 特征选择:提取训练集两个类别文件中最易区分的前K个词作为特征词列表
def feature_selection(counterlist1, counterlist2, topk=None):
    counter1 = reduce(lambda x, y: x + y, counterlist1)
    counter2 = reduce(lambda x, y: x + y, counterlist2)
    counter_total = counter1 + counter2
    for key in counter_total:
        if counter1[key] > counter2[key]:
            counter_total[key] = log(float(counter1[key] + 1) / float(counter2[key] + 1))
        else:
            counter_total[key] = log(float(counter2[key] + 1) / float(counter1[key] + 1))
    if topk is None:
        topk = len(counter_total) / 10
    return [features for features, num in counter_total.most_common(topk)]


# 计算特征词列表在训练集中两个类别文件中的IDF=log((|D|+1)/(DF(t,D)+1)),其中|D|是总文件个数， DF(t,D)是多少个文件包含了t
def idf(counterlist1, counterlist2, features):
    counterlist = counterlist1 + counterlist2
    DF = [sum(word in counter.keys() for counter in counterlist) for word in features]
    return [log(float(len(counterlist) + 1) / float(df + 1)) for df in DF]


# 计算每类文件中每篇文本的tf
def tf(counterlist, features):
    return [[text[word] for word in features] for text in counterlist]


# 将每类文件夹中每篇文本表示为特征向量
def feature_vector(tf_list, idf):
    return [[i_tf * i_idf for i_tf, i_idf in zip(tf, idf)] for tf in tf_list]
